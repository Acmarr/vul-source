#!/usr/bin/env python3
# Author: Giampaolo Fresi Roglia <giampaolo.fresi.roglia@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# Partition kernels released in the given cycle by kernel family and
# set of fixed cves.
#

import argparse
import os
import re
import time
import cve_lib
import usn_lib
import kernel_lib
import sys

try:
    import lpl_common
    from lp_lib import UCTLaunchpad
except Exception:
    print("Warning! lpl_common.py is missing.")

KERNEL_TAG_PREFIX = 'kernel-sru-cycle-'
NEXT_USN = 0

def main():
    args = parse_arguments()

    # Initialize launchpad client
    try:
        uctlp = UCTLaunchpad({"debug": args.debug})
    except NameError:
        # exiting without printing any message. this error happens
        # because we failed to import lpl_common and we already
        # printed a message at import time.
        sys.exit(1)

    # Load USN database
    usndb = usn_lib.USNdb([], db=args.database, opt=usn_lib.USNdbOpt(debug=args.debug, use_glitches=True))

    # Load all CVEs
    active, embargoed = cve_lib.get_cve_list()
    cve_lib.build_subproject_dir_cache()
    cves = cve_lib.load_all(active, embargoed)

    esm_releases = get_esm_releases()

    kernel_families = get_kernel_tasks(args.cycle, esm_releases, args.verbose)

    if kernel_families is None:
        sys.exit(-1)

    allusns, without_cves = partition_kernels(args.cycle, usndb, uctlp, cves, kernel_families, verbose=args.verbose)

    print_cycle_info(allusns, without_cves, args.untracked)

def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument("-d", "--debug", dest="debug", help="Report additional debugging while processing", action='store_true')
    parser.add_argument("-v", "--verbose", dest="verbose", help="Report additional information while processing", action='store_true')
    parser.add_argument("-c", "--cycle", dest="cycle", help="only report signoff bugs for a specific kernel cycle tag (default: any)", default="any")
    parser.add_argument("-D", "--database", dest="database", help="Specify location of USN data (default 'database.pickle')", default=os.path.join(os.getenv("UCT"), "database.pickle"))
    parser.add_argument("-u", "--report-untracked", dest="untracked", help="report untracked kernel versions (default false)", action='store_true')
    return parser.parse_args()

def get_esm_releases():
    esm_releases = []
    for release in cve_lib.get_active_releases_with_esm():
        if cve_lib.is_active_esm_release(release):
            esm_releases.append(release)
    return esm_releases

def _task_searcher(cycle):
    sec = security_signoff_tasks()
    return sec.searchTasks(omit_targeted=False,
                           status=["Confirmed", "In Progress", "Fix Released", "Invalid"],
                           tags=cycle_search_terms(cycle), tags_combinator="Any")

def get_kernel_tasks(cycle="any", esm_releases=None, verbose=False, task_searcher=_task_searcher):
    res = dict()

    if cycle == "any":
        if verbose:
            print("get_kernel_tasks: cycle=\"any\": not implemented yet.")
        return None

    tasks = []
    for task in task_searcher(cycle):
        if not hasattr(task, 'bug'):
            continue
        if not hasattr(task, 'status'):
            continue
        status = task.status
        # security-signoff tasks in need of an actual security signoff
        # do have a status of "Confirmed", "In Progress" or
        # "Fix Released"
        if status in ["Confirmed", "In Progress", "Fix Released"]:
            tasks.append(task)
            continue
        # for esm releases, we do not perform any security signoff
        # the tasks we are interested in are among the ones marked as "Invalid"
        # so we first ignore everything else.
        if status != "Invalid":
            continue
        # Among the "Invalid" tasks we keep the ones tagged with the
        # names of active esm releases.
        for release in esm_releases:
            if hasattr(task.bug, 'tags') and release in task.bug.tags:
                tasks.append(task)

    for task in tasks:
        try:
            bug = SignoffBug(task, verbose)
        except ValueError as e:
            if verbose:
                print(f"ignoring task: {task}, exception: {e}")
            continue
        res.setdefault(bug.kernel_series, []).append(bug)

    return res

def partition_kernels(cycle, usndb, uctlp, cves, kernel_families, verbose=False, out=sys.stdout):
    allusns = dict()
    without_cves = set()

    if verbose:
        print(f'========== {cycle} cycle ==========', file=out)
    for kernel_family in sorted(kernel_families, key=kernel_cmp_key, reverse=True):
        usns = dict()
        if verbose:
            print(f'========== kernel family {kernel_family}  ==========', file=out)
        for bug in sorted(kernel_families[kernel_family]):
            if "riscv" in bug.kernel or "fips" in bug.kernel or "cascade" in bug.kernel:
                continue
            latest_version = usndb.get_latest_usn_version(bug.kernel, bug.release)
            if not latest_version:
                latest_version = uctlp.get_earliest_version(bug.release, bug.kernel)
            if latest_version == bug.version:
                continue

            release_name = cve_lib.get_esm_name(bug.release)
            if release_name is None:
                release_name = bug.release
            cveset = set([x[0] for x in kernel_lib.get_kernel_pending_fixes(cves, bug.kernel, latest_version, bug.version, [release_name])])
            if len(cveset) == 0:
                without_cves.add(bug)
                continue
            setid = set_id(cveset)
            if setid not in usns:
                usns[setid] = {"cves": cveset, "name": next_usn(), "entries": set()}
            usns[setid]["entries"].add(bug)

            if verbose:
                print(f"{bug.release} {bug.kernel}: {bug.version} (prev: {latest_version})", file=out)
        allusns[kernel_family] = usns
    return (allusns, without_cves)

def print_cycle_info(allusns, without_cves, report_untracked=False, out=sys.stdout):
    for kernel_family, usns in sorted(allusns.items(), key=lambda item: kernel_cmp_key(item[0]), reverse=True):
        print(f"kernel family: {kernel_family}", file=out)
        cves = None
        for u in usns.values():
            print(f'   {u["name"]}', file=out)

            for k in sorted(u["entries"]):
                print(f"      {k}", file=out)

            print("   CVEs:", file=out)
            print_items_per_line(u["cves"], prefix="      ", out=out)
            if not cves:
                cves = u["cves"]
            else:
                cmpcves = u["cves"]
                if len(cves - cmpcves) > 0:
                    print("   missing cves:", file=out)
                    print_items_per_line(cves - cmpcves, prefix="      ", out=out)
                if len(cmpcves - cves) > 0:
                    print("   additional cves:", file=out)
                    print_items_per_line(cmpcves - cves, prefix="      ", out=out)
    if len(without_cves) > 0 and report_untracked:
        print("without cves (untracked kernels or already published kernel versions):", file=out)
        for k in sorted(without_cves):
            print(f"   {k}", file=out)

def security_signoff_tasks():
    count = 10
    sec = None
    while True:
        try:
            lp = lpl_common.connect(version="1.0")
            sec = lp.projects['kernel-sru-workflow'].getSeries(name="security-signoff")
            break
        except Exception:
            count -= 1
            if count <= 0:
                raise
            time.sleep(5)
            pass
    return sec

class SignoffBug(object):
    def __init__(self, task, verbose=False):
        bug = task.bug
        self.title = bug.title
        self.verbose = verbose
        self.url = str(bug)
        self.id = bug.id
        if self.verbose:
            print(f"title: {self.title}")
            print(f"bug id: {self.id}")
            print(f"security-signoff status: {task.status}")
        m = re.search("([^/]+)/([^:]+):[ ]*(.*) -proposed tracker", self.title)
        if not m:
            raise ValueError(f"bug {bug} has wrong title format")

        self.release, self.kernel, self.version = m.groups()
        if self.verbose:
            print(f"release: {self.release}, kernel: {self.kernel}, version: {self.version}")
        if self.version == "<version to be filled>":
            raise ValueError(f"bug {bug} does not have a version yet")
        self.kernel_series = self.version.split('-')[0]

        cycle = 'missing'
        for tag in bug.tags:
            if tag.startswith(KERNEL_TAG_PREFIX):
                cycle = tag.split('-', maxsplit=3)[3]
        self.cycle = cycle

    def __lt__(self, other):
        # sort signoff bugs by kernel family first (6.8.0 < 5.15.0 < 5.4.0), then by release
        # (noble (24.04) < jammy (22.04)) and then by kernel name
        # (linux < linux-aws < linux-azure)
        s = kernel_cmp_key(self.kernel_series)
        o = kernel_cmp_key(other.kernel_series)
        for i in range(max(len(s), len(o))):
            if s[i] > o[i]:
                return True
            if s[i] < o[i]:
                return False
        s = cve_lib.subprojects[f"ubuntu/{self.release}"]["version"]
        o = cve_lib.subprojects[f"ubuntu/{other.release}"]["version"]
        if not s == o:
            return s > o
        return self.kernel < other.kernel

    def __str__(self):
        return f"{self.release}/{self.kernel}: {self.version}"

def cycle_search_terms(cycle):
    m = re.search(r"(s?[0-9]{4}[.][0-9]{2}[.][0-9]{2})(-.*)?", cycle)
    if not m:
        raise ValueError("wrong format for cycle")
    if m.group(2):
        return [KERNEL_TAG_PREFIX + cycle]
    return [KERNEL_TAG_PREFIX + cycle + "-%d" % x for x in range(1, 20)]

def kernel_cmp_key(version_string):
    # turns '4.15.0' -> [4, 15, 0] for sorting
    return [int(x) for x in version_string.split('.')]

def set_id(s: set[str]) -> str:
    return hash(''.join(sorted(s)))

def next_usn() -> str:
    global NEXT_USN
    res = "USN-{:04d}-1".format(NEXT_USN)
    NEXT_USN = NEXT_USN + 1
    return res

def cveid_cmp_key(cve_id):
    cve_id = cve_id.split()[0]
    year = int(cve_id.split('-')[1])
    number = int(cve_id.split('-')[2])
    return (year, number)

def print_items_per_line(items, count=4, prefix="", out=sys.stdout):
    if items is None:
        raise ValueError("items is None")
    items = sorted(list(items), key=cveid_cmp_key)
    for i in range(0, len(items), count):
        line = [item.split()[0] for item in items[i:i + count]]
        print(prefix + " ".join(line), file=out)


if __name__ == '__main__':
    main()
