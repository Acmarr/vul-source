#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data 
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

from .models import CVE, SN, SourcePackage, BinaryPackage, CVEPkgEntry, Version, CVSS
from cve_lib import get_subproject_details, get_active_esm_releases, is_active_release
from datetime import datetime

class UbuntuVersion(Version):
    def is_esm(self) -> bool:
        return 'esm' in self.version

class Release:
    name: str
    canon: str
    alias: str
    version: "UbuntuVersion"
    codename: str
    product: str
    series: str
    ppas: list[dict]
    description: str
    stamp: datetime
    components: list
    is_devel: bool
    is_esm: bool
    is_active: bool
    requires_oval: bool
    parent: "Release"
    esm_infra_release: "Release"
    esm_apps_release: "Release"

    def __init__(self, name: str) -> None:
        canon, product, series, details = get_subproject_details(name)
        self.parent = None
        self.version = None
        self.codename = None
        self.esm_infra_release = None
        self.esm_apps_release = None
        self.alias = None
        self.is_devel = False

        if not canon:
            self.canon = name
            self.name = name
            self.parent = None
            return

        self.canon = canon
        self.name = canon
        self.product = product
        self.series = series
        self.ppas = list()
        self.components = list()
        self.description = ''
        self.stamp = None
        if not details: return
        if 'oval' in details:
            self.requires_oval = details['oval']
        else:
            self.requires_oval = True
        if 'name' in details:
            self.name = details['name']
        if 'ppas' in details:
            self.ppas = details['ppas']
        if 'description' in details:
            self.description = details['description']
        if 'components' in details:
            self.components = details['components']
        if 'stamp' in details:
            self.stamp = datetime.fromtimestamp(details['stamp'])
        if 'parent' in details:
            self.parent = details['parent']
        if 'version' in details:
            self.version = Version(str(details['version']))
        if 'codename' in details:
            self.codename = details['codename']
        if 'codename' in details:
            self.codename = details['codename']
        if 'devel' in details:
            self.is_devel = details['devel']
        if 'alias' in details:
            self.alias = details['alias']
        if 'release' in details and not self.parent:
            self.parent = details['release']
        self.is_active = is_active_release(self.canon if not self.alias else self.alias)
        self.is_esm = self.canon in get_active_esm_releases() or self.alias in get_active_esm_releases()

    def __eq__(self, value: object) -> bool:
        if not hasattr(value, 'canon'): return False
        return self.canon == value.canon

    def __repr__(self) -> str:
        return self.canon if not self.alias else self.alias

    def __hash__(self):
        return hash(self.canon)
    
    def __lt__(self, other: "Release") -> bool:
        if not hasattr(other, 'version'): return False
        if self.get_version() == other.get_version():
            if not self.parent:
                # Base release vs other
                return True
            elif not other.parent:
                # Other vs base release
                return False
            elif self.is_esm and other.is_esm:
                # ESM vs ESM - Infra first
                return self == other.parent
            elif self.is_esm and other.parent:
                # ESM vs External
                return True
            elif not self.is_esm and not other.is_esm:
                # External vs external - alphabetical order  
                return self.canon < other.canon
            else:
                return False
        else:
            return self.get_version() < other.get_version()

    def get_version(self) -> "UbuntuVersion":
        target_rel_version = self.version            
        if not target_rel_version:
            target_rel_version = self.get_oldest_parent().version

        return target_rel_version

    def is_parent_release(self, release: "Release") -> bool:
        return release in self.get_all_parents()
    
    def get_direct_parent(self) -> "Release":
        return self.parent

    def get_all_parents(self) -> list["Release"]:
        release = self
        all_parents = []
        while release.parent:
            release = release.parent
            all_parents.append(release)
        return all_parents

    def get_oldest_parent(self) -> "Release":
        if not self.parent: return None
        return  self.get_all_parents()[-1]


class UbuntuBinaryPackage(BinaryPackage):
    component: str

    def __init__(self, name: str, version: "UbuntuVersion", arches: list[str], source: "UbuntuSourcePackage", component: str) -> None:
        self.component = component
        super().__init__(name, version, arches, source)
    
class UbuntuSourcePackage(SourcePackage):
    source_info: dict["Release": dict["UbuntuVersion": dict]]
    binaries: dict["Release": dict["UbuntuVersion":list["UbuntuBinaryPackage"]]]
    source_versions: dict["Release": set["Version"]]

    def __init__(self, name) -> None:
        self.name = name
        self.source_info = {}
        self.binaries = {}
        self.source_versions = {}

    def get_binaries(self, release: "Release", version: "Version") -> list["BinaryPackage"]:
        if release not in self.get_releases(): return []
        if version not in self.binaries[release]: return []
        return self.binaries[release][version]

    def add_binary(self, release: "Release", src_version: "Version", binary: "BinaryPackage") -> None:
        if release not in self.get_releases(): return
        if src_version not in self.binaries[release]: return
        if binary not in self.binaries[release][src_version]:
            self.binaries[release][src_version].append(binary)

    def is_binary_present(self, release: "Release", src_version: "Version", binary: "BinaryPackage") -> bool:
        if release not in self.get_releases(): return
        if src_version not in self.binaries[release]: return False
        return binary in self.binaries[release][src_version]

    def add_source_version(self, release: "Release", version: "UbuntuVersion", component: str, pocket: str):
        self.source_info.setdefault(release, dict())
        self.binaries.setdefault(release, dict())
        self.source_versions.setdefault(release, set())
        if version in self.source_versions[release]: return
        self.source_info[release][version] = {
            'pocket': pocket,
            'component': component
        }

        self.source_versions[release].add(version)
        self.binaries[release][version] = []

    def get_version_component(self, release: "Release", version: "UbuntuVersion") -> str:
        if release not in self.get_releases(): return None
        if version not in self.source_versions[release]: return None
        return self.source_info[release][version]['component']
    
    def get_version_pocket(self, release: "Release", version: "UbuntuVersion") -> str:
        if release not in self.get_releases(): return None
        if version not in self.source_versions[release]: return None
        return self.source_info[release][version]['pocket']

    def get_release_source_versions(self, release: "Release") -> set["UbuntuVersion"]:
        if release not in self.source_versions: return set()
        return self.source_versions[release]

    def get_releases(self) -> list["Release"]:
        return list(sorted(self.source_versions.keys()))

    def get_latest_version(self, release: "Release") -> "UbuntuVersion":
        source_versions = self.get_release_source_versions(release)
        if not source_versions: return None

        latest = None
        for source_version in source_versions:
            if not latest or source_version > latest:
                latest = source_version

        return latest

    def get_earliest_version(self, release: "Release") -> "UbuntuVersion":
        source_versions = self.get_release_source_versions(release)
        if not source_versions: return None

        earliest = None
        for source_version in source_versions:
            if not earliest or source_version < earliest:
                earliest = source_version

        return earliest

    def expand_versions(self, other: "UbuntuSourcePackage") -> None:
        for release in other.get_releases():
            self.source_info.setdefault(release, dict())
            self.binaries.setdefault(release, dict())
            self.source_versions.setdefault(release, set())
            self.source_versions[release].update(other.source_versions[release])
            self.source_info[release].update(other.source_info[release])
            self.binaries[release].update(other.binaries[release])
    
    def remove_version(self, release: "Release", version: "UbuntuVersion") -> None:
        if release not in self.source_versions: return 
        self.source_versions[release].remove(version)
        del self.source_info[release][version]
        del self.binaries[release][version]

    def release_exists(self, release: "Release", include_parents: bool) -> bool:
        """
        Check if release exists in the package.

        If include_parents, it will also check if any of the release
        parents are listed.
        """
        all_releases = self.get_releases()
        releases_to_check = set([release])
        if include_parents:
            releases_to_check.update(release.get_all_parents())

        for release in releases_to_check:
            if release in all_releases: return True
        
        return False

    def __repr__(self) -> str:
        return f'{self.name}'
    
    def __hash__(self) -> int:
        return hash(self.name)

class UbuntuCVEPkgEntry(CVEPkgEntry):
    release: Release

    def __init__(self, pkg: "UbuntuSourcePackage", cve: 'UbuntuCVE', status: str, note: str, release: "Release") -> None:
        self.release = release
        super().__init__(pkg, cve, status, note)

class UbuntuCVE(CVE):
    pkg_entries: list[UbuntuCVEPkgEntry]

    def __init__(self, id: str, description: str, public_date: str, cvss: list[CVSS], assigned_to: str, notes: list[tuple], references: list[str], priority: str, priority_reason: str) -> None:
        super().__init__(id, description, public_date, cvss, assigned_to, notes, references, priority, priority_reason)

    def is_rel_present(self, release: "Release") -> bool:
        for entry in self.pkg_entries:
            if entry.release == release: return True
        return False

    def add_cve_entry(self, entry: "UbuntuCVEPkgEntry") -> bool:
        for self_entry in self.pkg_entries:
            if self_entry.pkg == entry.pkg and \
                self_entry.release == entry.release:
                return False
        self.pkg_entries.append(entry)
        return True

    def get_public_date(self) -> datetime:
        for format in ['%Y-%m-%d %H:%M:%S %Z', '%Y-%m-%d']:
            try:
                return datetime.strptime(self.public_date, format).isoformat(timespec="seconds")
            except ValueError:
                pass
        return None

    def get_releases(self) -> list["Release"]:
        releases = set()
        for pkg_entry in self.pkg_entries:
            releases.add(pkg_entry.release)
        
        return list(sorted(releases))

    def get_entries_affecting_release(self, release: "Release") -> list[tuple["SourcePackage", "Version"]]:
        entries = []
        for entry in self.pkg_entries:
            if entry.release == release:
                entries.append(entry)
        
        return list(sorted(entries, key=lambda entry: entry.pkg.name))

    def __repr__(self) -> str:
        return self.id

    def __hash__(self) -> int:
        return hash(self.id)
    

class USN(SN):
    package_fixed_versions: dict["SourcePackage":list[tuple["Version", "Release"]]]
    raw_data: dict
    releases: list["Release"]
    raw_binaries: dict["Release": dict]

    def __init__(self, id: str, data: dict, cve_objs: set, package_fixed_versions: dict, lp_bugs: set):
        for item in ['description', 'title', 'timestamp', 'summary', 'action', 'id', 'isummary']:
            if item in data:
                setattr(self, item, data[item])
            else:
                setattr(self, item, None)

        self.id = id
        self.lp_bugs = lp_bugs
        self.cves = cve_objs
        self.package_fixed_versions = package_fixed_versions            
        self.raw_data = data

    def is_rel_present(self, release: "Release") -> bool:
        return release in self.releases

    def get_releases(self) -> list["Release"]:
        return self.releases

    def get_public_date(self) -> datetime:
        return datetime.fromtimestamp(self.timestamp).isoformat(timespec="seconds")

    def get_cves_affecting_release(self, release: "Release") -> list["UbuntuCVE"]:
        release_cves = []
        for cve in self.cves:
            for pkg_entry in cve.pkg_entries:
                if pkg_entry.release == release and \
                    pkg_entry.status == 'released' and \
                    pkg_entry.pkg in self.package_fixed_versions:
                        release_cves.append(cve)
                        break
                elif 'regresion' in self.title:
                    release_cves.append(cve)

        return list(sorted(release_cves))
    
    def get_package_info_affecting_release(self, release: "Release") -> list[tuple["SourcePackage", "Version"]]:
        pkgs_info = []
        for package in self.package_fixed_versions:
            for version,pkg_rel in self.package_fixed_versions[package]:
                if pkg_rel == release:
                    pkgs_info.append((package, version))
        
        return list(sorted(pkgs_info))

    def get_raw_binaries(self, release: "Release", package_name: str) -> list[dict]:
        """
        This function allows to retrieve the raw binary data from the
        USN for a specific release-package. This should only be used
        if the version doesn't exist in the package storage.
        """
        if release.parent:
            release = release.get_oldest_parent()
        
        if release not in self.raw_binaries: return list()
        if package_name not in self.raw_binaries[release]: return list()
        return self.raw_binaries[release][package_name]
        