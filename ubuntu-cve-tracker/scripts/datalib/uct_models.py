#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data 
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#

from datalib.models import CVSS
from .models import *
from cve_lib import get_subproject_details, get_active_esm_releases, is_active_release

class Release:
    name: str
    version: str
    codename: str
    product: str
    series: str
    is_esm: bool
    is_active: bool
    requires_oval: bool
    parent: "Release"

    def __init__(self, name: str) -> None:
        canon, product, series, details = get_subproject_details(name)
        if not canon:
            self.name = name
            self.parent = None
            return
        self.name = canon
        self.product = product
        self.series = series
        self.is_esm = self.name in get_active_esm_releases()
        self.is_active = is_active_release(self.name)
        self.parent = None
        self.version = None
        self.codename = None
        if not details: return
        if 'oval' in details:
            self.requires_oval = details['oval']
        else:
            self.requires_oval = True
        if 'parent' in details:
            self.parent = Release(details['parent'])
        if 'version' in details:
            self.version = details['version']
        if 'codename' in details:
            self.codename = details['codename']

    def __eq__(self, value: object) -> bool:
        return self.name == value.name

    def __repr__(self) -> str:
        return self.name

    def __hash__(self):
        return hash(self.name)

    def get_esm_release(self, component: str) -> "Release":
        esm_releases = get_active_esm_releases()
        potential_releases = list(filter(lambda release: self.series in release, esm_releases))
        if len(potential_releases) == 1:
            return Release(potential_releases[0])
        elif len(potential_releases) == 2:
            if component in ['main', 'restricted']:
                target = 'esm-infra'
            elif component in ['universe', 'multiverse']:
                target = 'esm-apps'
            
            if target in potential_releases[0]: return Release(potential_releases[0])
            else: return Release(potential_releases[1])

        return None
    def is_parent_release(self, release: "Release") -> bool:
        return release in self.get_all_parents()
    
    def get_direct_parent(self) -> "Release":
        return self.parent

    def get_all_parents(self) -> "Release":
        release = self
        all_parents = []
        while release.parent:
            release = release.parent
            all_parents.append(release)
        return all_parents

    def get_oldest_parent(self) -> "Release":
        if not self.parent: return None
        return  self.get_all_parents()[-1]

class UbuntuVersion(Version):
    def is_esm(self) -> bool:
        return 'esm' in self.version

class UbuntuBinaryPackage(BinaryPackage):
    component: str

    def __init__(self, name: str, version: UbuntuVersion, arches: list[str], source: 'UbuntuSourcePackage', component: str) -> None:
        self.component = component
        super().__init__(name, version, arches, source)
    
class UbuntuSourcePackage(SourcePackage):
    source_info: dict[UbuntuVersion: dict]
    binaries: dict[UbuntuVersion:list[UbuntuBinaryPackage]]

    def __init__(self, name, binaries) -> None:
        self.source_info = {}
        super().__init__(name, binaries)

    def add_source_version(self, version: UbuntuVersion, release: Release, component: str, pocket: str):
        if version in self.source_versions: return
        self.source_info[version] = {
            'pocket': pocket,
            'component': component,
            'release': release
        }
        return super().add_source_version(version)

    def get_version_release(self, version: UbuntuVersion) -> Release:
        if version not in self.source_versions: return None
        return self.source_info[version]['release']

    def get_version_component(self, version: UbuntuVersion) -> str:
        if version not in self.source_versions: return None
        return self.source_info[version]['component']
    
    def get_version_pocket(self, version: UbuntuVersion) -> str:
        if version not in self.source_versions: return None
        return self.source_info[version]['pocket']

    def get_release_source_versions(self, release: Release, include_parents: bool = False, include_esm: bool = False) -> set[UbuntuVersion]:
        rel_versions = set()
        for source_version in self.source_versions:
            source_version_rel = self.get_version_release(source_version)
            component = self.get_version_component(source_version)
            if (include_parents and release.is_parent_release(source_version_rel)) or \
                (include_esm and source_version_rel == release.get_esm_release(component)) or \
                source_version_rel == release:
                rel_versions.add(source_version)

        return rel_versions

    def get_latest_version(self, release: Release = None, include_parents: bool = False, include_esm: bool = False) -> UbuntuVersion:
        if release:
            source_versions = self.get_release_source_versions(release, include_parents, include_esm)
        else:
            source_versions = self.get_source_versions()

        if not source_versions: return None

        latest = None
        for source_version in source_versions:
            if not latest or source_version > latest:
                latest = source_version

        return latest

    def get_earliest_version(self, release: Release = None, include_parents: bool = False, include_esm: bool = False) -> UbuntuVersion:
        if release:
            source_versions = self.get_release_source_versions(release, include_parents, include_esm)
        else:
            source_versions = self.get_source_versions()

        if not source_versions: return None

        earliest = None
        for source_version in source_versions:
            if not earliest or source_version < earliest:
                earliest = source_version

        return earliest

    def expand_versions(self, other: "UbuntuSourcePackage") -> None:
        self.source_versions.update(other.source_versions)
        self.source_info.update(other.source_info)
        self.binaries.update(other.binaries)
    
    def remove_version(self, version: UbuntuVersion) -> None:
        self.source_versions.remove(version)
        del self.source_info[version]
        del self.binaries[version]

    def release_exists(self, release: Release, include_parents: bool) -> bool:
        """
        Check if release exists in the package.

        If include_parents, it will also check if any of the release
        parents are listed.
        """
        for _, entry in self.source_info.items():
            if release == entry['release']:
                return True
            if include_parents and release.is_parent_release(entry['release']): 
                return True
        
        return False

    def __repr__(self) -> str:
        return f'{self.name}'
    
    def __hash__(self) -> int:
        return hash(self.name)

class UbuntuCVEPkgEntry(CVEPkgEntry):
    release: Release

    def __init__(self, pkg: UbuntuSourcePackage, cve: 'UbuntuCVE', status: str, note: str, release: Release) -> None:
        self.release = release
        super().__init__(pkg, cve, status, note)

class UbuntuCVE(CVE):
    pkg_entries: list[UbuntuCVEPkgEntry]

    def __init__(self, id: str, description: str, public_date: str, cvss: list[CVSS], assigned_to: str, notes: list[tuple], references: list[str], priority: str, priority_reason: str) -> None:
        super().__init__(id, description, public_date, cvss, assigned_to, notes, references, priority, priority_reason)

    def is_rel_present(self, release: Release) -> bool:
        for entry in self.pkg_entries:
            if entry.release == release: return True
        return False

    def add_cve_entry(self, entry: UbuntuCVEPkgEntry) -> bool:
        for self_entry in self.pkg_entries:
            if self_entry.pkg == entry.pkg and \
                self_entry.release == entry.release:
                return False
        self.pkg_entries.append(entry)
        return True

    def __repr__(self) -> str:
        return self.id

    def __hash__(self) -> int:
        return hash(self.id)
    

class USN(SN):
    package_fixed_versions: dict[SourcePackage:list[tuple[Version, Release]]]
    releases: set[Release]

    def __init__(self, id: str, data: dict, cve_objs: set, package_fixed_versions: dict, lp_bugs: set):
        for item in ['description', 'releases', 'title', 'timestamp', 'summary', 'action', 'id', 'isummary']:
            if item in data:
                setattr(self, item, data[item])
            else:
                setattr(self, item, None)

        self.id = id
        self.lp_bugs = lp_bugs
        self.cves = cve_objs
        self.package_fixed_versions = package_fixed_versions

    def is_rel_present(self, release: Release) -> bool:
        return release in self.releases
