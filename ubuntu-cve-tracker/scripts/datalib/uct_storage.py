#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
import cve_lib
import datetime
import json
import logging
import os
import re

from .config import PKG_CACHE_DIR, UCT, USN_DATABASE
from .storage import PackageStorage, CVEStorage, SNStorage
from .uct_models import UbuntuCVE, USN, UbuntuSourcePackage, UbuntuBinaryPackage, UbuntuCVEPkgEntry, UbuntuVersion, CVE, Release, CVSS, SN

from multiprocessing import Pool


logger = logging.getLogger(__name__)

class ReleaseStorage():
    releases: list
    supported_releases: list
    esm_apps_releases: list
    esm_infra_releases: list

    def __init__(self) -> None:
        self.releases = {}
        self.supported_releases = []
        self.esm_apps_releases = []
        self.esm_infra_releases = []

        for release in cve_lib.all_releases:
            rel_obj = Release(release)
            self.releases[str(rel_obj)] = rel_obj

        # Link parents
        for release in self.releases.values():
            if release.parent:
                release.parent = self.get_release(release.parent)

        esm_releases = cve_lib.get_active_esm_releases()
        supported_releases_names = list(set(cve_lib.all_releases).difference(set(cve_lib.eol_releases)).difference(set([cve_lib.devel_release])))
        esm_infra_releases_names = list(filter(lambda release: release == 'trusty/esm' or 'esm-infra/' in release, esm_releases))
        esm_apps_releases_names = list(filter(lambda release: 'esm-apps/' in release, esm_releases))

        for release in supported_releases_names:
            self.supported_releases.append(self.get_release(release))
        for release in esm_infra_releases_names:
            rel_obj = self.get_release(release)
            self.esm_infra_releases.append(rel_obj)
            rel_obj.get_oldest_parent().esm_infra_release = rel_obj
        for release in esm_apps_releases_names:
            rel_obj = self.get_release(release)
            self.esm_apps_releases.append(rel_obj)
            rel_obj.get_oldest_parent().esm_apps_release = rel_obj

    def get_all_releases(self) -> list:
        return list(self.releases.values())

    def get_release(self, release_name: str) -> Release:
        if release_name == 'devel':
            return self.get_devel_release()

        for release in self.releases.values():
            if release.canon == release_name or \
                release.alias == release_name:
                return release

        return None

    def get_releases(self, releases_names: list) -> list:
        return list(map(lambda release_name: self.get_release(release_name), releases_names))

    def get_product_releases(self, product: str, supported_only: bool = False) -> list:
        """Get all releases that belong to a product"""
        if supported_only:
            releases = list(filter(lambda release: release.product == product, self.supported_releases))
        else:
            releases = list(filter(lambda release: release.product == product, self.releases.values()))
        return releases

    def get_devel_release(self) -> Release:
        for release in self.releases.values():
            if release.is_devel:
                return release

        return None

class UCTPackageStorage(PackageStorage):
    """
    Storage class for handling UCT packages.
    """
    packages: dict
    latest_date_created: dict
    loaded_releases: set
    release_storage: ReleaseStorage

    def __init__(self) -> None:
        self.loaded_releases = set()
        self.latest_date_created = {}
        self.release_storage = None
        super().__init__()

    def load(self, filter_releases: list = [], multithreading: bool = False) -> None:
        """
        Note that link_release_storage function need to be called
        before.
        """
        self.dirty_cache.increment_last_updated()
        releases = self.release_storage.supported_releases if not filter_releases else filter_releases
        final_releases = set()

        for release in releases:
            final_releases.add(release)
            while release.parent:
                release = release.parent
                if release not in final_releases:
                    final_releases.add(release)

        logger.debug(f'Loading {len(final_releases)} releases')
        if multithreading:
            with Pool(processes=os.cpu_count()) as pool:
                package_data = pool.map(self._load_release_from_cache, final_releases)
        else:
            package_data = []
            for release in final_releases:
                package_data.append(self._load_release_from_cache(release))

        for release, release_data, last_date_created in package_data:
            self._init_release(release, release_data, last_date_created)

        self._order_packages()

    def _load_release_from_cache(self, release: Release)  -> dict:
        data = {}
        pkg_cache_filename = []
        if release.canon == 'esm/trusty':
            pkg_cache_filename = 'trusty_esm'
        elif release.product == 'ubuntu':
            pkg_cache_filename = release.series
        else:
            pkg_cache_filename = release.canon.replace('/', '_')

        try:
            with open(os.path.join(os.path.expanduser(PKG_CACHE_DIR), pkg_cache_filename + '-pkg-cache.json')) as f:
                data = json.load(f)
        except FileNotFoundError:
            logger.debug(f'Couldn\'t find package cache for release {release.canon} with filename {pkg_cache_filename}')
            return (release, None, None)

        release_data = {}
        latest_date_created = None
        for src_pkg_name, src_pkg_versions in data.items():
            if src_pkg_name == 'latest_date_created':
                latest_date_created = datetime.datetime.fromtimestamp(src_pkg_versions)
                continue
            source_package = UbuntuSourcePackage(src_pkg_name)

            release_data[src_pkg_name] = source_package
            for src_pkg_version, src_pkg_version_data in src_pkg_versions.items():
                src_pkg_version_obj = UbuntuVersion(src_pkg_version)
                source_package.add_source_version(release, src_pkg_version_obj,
                                                  src_pkg_version_data['component'],
                                                  src_pkg_version_data['pocket'])

                for binary_name, binary_data in src_pkg_version_data['binaries'].items():
                    source_package.add_binary(release, src_pkg_version_obj, UbuntuBinaryPackage(binary_name,
                                                                  UbuntuVersion(binary_data['version']),
                                                                  binary_data['arch'],
                                                                  source_package,
                                                                  binary_data['component']))

            source_package.source_versions = dict(sorted(source_package.source_versions.items()))
            source_package.binaries = dict(sorted(source_package.binaries.items()))
            source_package.source_info = dict(sorted(source_package.source_info.items()))

        return (release, release_data, latest_date_created)

    def _init_release(self, release: Release, release_data: dict, latest_date_created: str) -> None:
        if not release_data: return
        for package_name in release_data:
            if package_name in self.packages:
                self.packages[package_name].expand_versions(release_data[package_name])
            else:
                self.packages[package_name] = release_data[package_name]

        self.latest_date_created[release] = latest_date_created
        self.loaded_releases.add(release)

    def get_package(self, pkg_name: str) -> UbuntuSourcePackage:
        return super().get_package(pkg_name)

    def load_release(self, release: Release) -> None:
        if self.release_storage.get_release(release) in self.loaded_releases: return
        release_obj, data, date = self._load_release_from_cache(release)
        self._init_release(release_obj, data, date)

    def unload_release(self, release: Release) -> None:
        release = self.release_storage.get_release(release)
        if release not in self.loaded_releases: return
        self.loaded_releases.remove(release)

        for package_name, package in self.packages.items():
            original_source_versions = package.source_versions.copy()
            for version in original_source_versions:
                ver_rel = package.get_version_release(version)
                if ver_rel == release: package.remove_version(version)

    def link_release_storage(self, release_storage: ReleaseStorage) -> None:
        self.release_storage = release_storage

class UCTCVEStorage(CVEStorage):
    """
    Storage class for handling UCT CVE packages.
    """
    cves: dict
    package_storage: UCTPackageStorage
    release_storage: ReleaseStorage

    # TODO: add a changed cache so we can cache CVEs and only update when something got loaded
    def __init__(self) -> None:
        self.release_storage = None
        super().__init__()

    def link_release_storage(self, release_storage: ReleaseStorage) -> None:
        self.release_storage = release_storage

    def load(self, cves_filter: list = []) -> None:
        """
        Note that link_release_storage function need to be called
        before.
        """
        self.dirty_cache.increment_last_updated()
        final_cves = []
        cves_ids = self.get_uct_cve_ids()
        for cve_id in cves_ids:
            if cves_filter and cve_id not in cves_filter: continue
            final_cves.append(cve_id)

        with Pool(processes=os.cpu_count()) as pool:
            logger.debug(f'Loading {len(final_cves)} CVEs')
            cves = pool.map(self._uct_cve_loader, final_cves)

        for cve, cve_pkg_data in cves:
            if not cve: continue
            self._init_cve(cve, cve_pkg_data)

        self._order_cves()

    def _uct_cve_loader(self, cve_id: str) -> UbuntuCVE:
        """Internal function to load CVE from UCT"""
        data = {}
        for directory in cve_lib.cve_dirs:
            try:
                data = cve_lib.load_cve(os.path.join(UCT, directory, cve_id))
            except:
                continue

        if not data:
            raise FileNotFoundError(f'Couldn\'t find CVE {cve_id}')

        cvss = []
        for cvss_entry in data['CVSS']:
            if not cvss_entry: continue

            cvss.append(CVSS(
                cvss_entry['source'],
                float(cvss_entry['baseScore']),
                cvss_entry['vector']
            ))

        try:
            cve = UbuntuCVE(data['Candidate'], data['Description'].strip().replace('\n', ' '), data['PublicDate'], cvss,
                            data['Assigned-to'], data['Notes'], data['References'].strip().split('\n'), data['Priority'][0], data['Priority'][1])
        except Exception as ex:
            logger.debug(ex)
            return (None, None)

        return (cve, data['pkgs'])

    def get_uct_cve_ids(self, ignored: bool = False, embargoed: bool = False) -> list:
        """Return all CVE IDs identified from UCT"""

        cve_ids = []
        cve_dirs = [cve_lib.active_dir, cve_lib.retired_dir]
        if ignored:
            cve_dirs.append(cve_lib.ignored_dir)
        if embargoed:
            cve_dirs.append(cve_lib.embargoed_dir)

        for dir in cve_dirs:
            for (_, _, filenames) in os.walk(dir):
                for filename in filenames:
                    if not re.search(CVE.ID_REGEX, filename): continue
                    cve_ids.append(filename)
                break

        return cve_ids

    def load_cve(self, cve_id: str) -> None:
        """Load a CVE into the storage"""
        cve, cve_data = self._uct_cve_loader(cve_id)
        self._init_cve(cve, cve_data)

    def get_all_cves(self) -> list:
        """Get all CVEs from the storage"""
        cves = []
        for cve_id in self.cves:
            cves.append(self.get_cve(cve_id))
        return cves

    def get_all_rel_cves(self, release: Release) -> list:
        """Get all CVEs from the storage affecting a release"""
        cves = []
        for cve_id in self.cves:
            cve = self.get_cve(cve_id)
            if cve.is_rel_present(release):
                cves.append()
        return cves

    def populate_cve_entries(self, cve_id: str) -> None:
        cve, cve_pkg_data = self.cves[cve_id]
        cve.pkg_entries = list()
        for package_name, package_entries in cve_pkg_data.items():
            package = self.package_storage.get_package(package_name)
            if not package: continue
            for release, status in package_entries.items():
                release = self.release_storage.get_release(release)
                if not release: continue
                if not package.release_exists(release, include_parents=True): continue
                cve.add_cve_entry(UbuntuCVEPkgEntry(package, cve, status[0], status[1], release))

    def get_cve(self, cve_id: str, with_pkg_links: bool = True) -> UbuntuCVE:
        """
        Get a CVE from the storage.
        The package links will be computed when the
        CVE is requested, extracting them from the internal
        UCTPackageStorage.

        If with_pkg_links is disabled, links won't be computed

        Note that link_release_storage and link_package_storage functions
        need to be called before if you want Release and Package objects
        to be linked to the CVE.
        """
        if cve_id not in self.cves: return None

        cve, _ = self.cves[cve_id]
        if not self.dirty_cache.is_dirty(cve_id, [self.package_storage.dirty_cache.last_updated]):
            return cve

        cve.pkg_entries = list()
        if not with_pkg_links: return cve
        self.populate_cve_entries(cve_id)

        self.dirty_cache.make_clean(cve_id)
        return cve

class USNStorage(SNStorage):
    sns: dict
    package_storage: UCTPackageStorage
    cve_storage: UCTCVEStorage
    release_storage: ReleaseStorage

    def __init__(self) -> None:
        self.release_storage = None
        super().__init__()

    def link_release_storage(self, release_storage: ReleaseStorage) -> None:
        self.release_storage = release_storage

    def load(self) -> None:
        self.dirty_cache.increment_last_updated()
        usns_data = self._get_usn_database_data()
        logger.debug(f'Loading {len(usns_data)} USNs')
        for usn_id, usn_data in usns_data.items():
            _, _, cves, lp_bugs, pkgs = self.process_usn_data((usn_id, usn_data))
            self._init_usn(USN(usn_id, usn_data, set(), dict(), lp_bugs), cves, pkgs)

        self._order_sns()

    def _init_usn(self, sn_object: SN, cves: set, pkgs: dict):
        self.sns[sn_object.id] = (sn_object, cves, pkgs)
        self.dirty_cache.add(sn_object.id)

    def _get_usn_database_data(self) -> dict:
        data = {}
        with open(os.path.expanduser(USN_DATABASE), 'r') as f:
            data.update(json.load(f))
        return data

    def process_usn_data(self, usn_raw: dict) -> tuple:
        pkgs = {}
        lp_bugs = set()
        cves = set()
        usn_id = usn_raw[0]
        usn_data = usn_raw[1]
        # Package - fixed version loading
        for rel, info in usn_data['releases'].items():
            # Get package
            if 'sources' in info:
                for pkg, pkg_info in info['sources'].items():
                    pkgs.setdefault(pkg, [])
                    pocket = None
                    # Best effort, there are too many corner cases
                    # since the format is not always the same for all
                    # USNs
                    if 'allbinaries' in info:
                        for binary_data in info['allbinaries'].values():
                            if 'source' in binary_data and binary_data['source'] != pkg: continue
                            if 'pocket' not in binary_data: continue
                            if pocket and binary_data['pocket'] != pocket:
                                # Different pocket in binaries, default to parent
                                pocket = None
                                break
                            elif not pocket:
                                pocket = binary_data['pocket']
                    pkgs[pkg].append((pkg_info['version'], pocket, rel))

        # CVE loading
        if 'cves' in usn_data:
            for cve_text in usn_data['cves']:
                if 'launchpad.net' in cve_text:
                    lp_bugs.add(cve_text)
                    continue
                elif re.search(r'CVE-\d{4}-\d{4,7}', cve_text):
                    cves.add(cve_text)

        return usn_id, usn_data, cves, lp_bugs, pkgs

    def get_usns_by_cve(self, cve_id: str) -> list:
        target_usns = []
        for usn_id, usn_data in self.sns.items():
            if cve_id in usn_data[1]:
                target_usns.append(self.get_usn(usn_id))

        return target_usns

    def get_usn(self, usn_id: str) -> USN:
        """
        Note that link_X_storage functions need to be called
        before if you want Package, CVE and Release objects to be linked
        to the USN.
        """
        if usn_id not in self.sns: return None
        usn, cves, pkgs = self.sns[usn_id]
        if not self.dirty_cache.is_dirty(usn_id,
                                         [self.cve_storage.dirty_cache.last_updated,
                                          self.package_storage.dirty_cache.last_updated]):
            return usn

        cve_mapping = set()
        pkg_mapping = dict()
        release_mapping = set()

        for cve_id in cves:
            cve = self.cve_storage.get_cve(cve_id)
            if not cve: continue
            cve_mapping.add(cve)

        for pkg_name in pkgs:
            pkg = self.package_storage.get_package(pkg_name)
            if not pkg: continue
            for version, pocket, release in pkgs[pkg_name]:
                release = self.release_storage.get_release(release)
                if not release: continue
                if not pkg.release_exists(release, include_parents=True): continue
                pkg_mapping.setdefault(pkg, [])
                version = UbuntuVersion(version)
                if pocket == 'esm-apps':
                    release = release.esm_apps_release
                elif pocket == 'esm-infra':
                    release = release.esm_infra_release

                release_mapping.add(release)
                pkg_mapping[pkg].append((version, release))

        usn.cves = cve_mapping
        usn.package_fixed_versions = pkg_mapping
        usn.releases = list(sorted(release_mapping))
        usn.raw_binaries = dict()

        for release in usn.raw_data['releases']:
            release_obj = self.release_storage.get_release(release)
            if 'allbinaries' in usn.raw_data['releases'][release]:
                if 'sources' not in usn.raw_data['releases'][release]: continue

                # In case sources are not listed with binaries
                sources_info = {}
                for source_name, source_data in usn.raw_data['releases'][release]['sources'].items():
                    sources_info[source_name] = source_data['version']

                for binary, binary_data in usn.raw_data['releases'][release]['allbinaries'].items():
                    if 'source' not in binary_data:
                        for source_name, source_version in sources_info.items():
                            if source_version == binary_data['version']:
                                usn.raw_binaries.setdefault(release_obj, dict())
                                usn.raw_binaries[release_obj].setdefault(source_name, dict())
                                usn.raw_binaries[release_obj][source_name][binary] = binary_data
                                break
                    else:
                        usn.raw_binaries.setdefault(release_obj, dict())
                        usn.raw_binaries[release_obj].setdefault(binary_data['source'], dict())
                        usn.raw_binaries[release_obj][binary_data['source']][binary] = binary_data

        self.dirty_cache.make_clean(usn_id)
        return usn
