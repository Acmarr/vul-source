#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data 
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
from .storage import *
from .uct_models import *
from .config import PKG_CACHE_DIR, USN_DATABASE
from .utils import get_active_ubuntu_releases
from .config import UCT

import json
import os
import cve_lib
from multiprocessing import Pool

class UCTPackageStorage(PackageStorage):
    """
    Storage class for handling UCT packages.
    """
    packages: dict[str: UbuntuSourcePackage]
    latest_date_created: dict[Release:datetime.datetime]
    loaded_releases: set[Release]

    def __init__(self) -> None:
        self.loaded_releases = set()
        self.latest_date_created = {}
        super().__init__()
    
    def load(self, filter_releases: list = []) -> None:
        final_releases = []
        active_ubuntu_releases = get_active_ubuntu_releases()
        for release in active_ubuntu_releases:
            if filter_releases and release not in filter_releases: continue
            final_releases.append(release)

        with Pool(processes=os.cpu_count()) as pool:
            print(f'Loading {len(final_releases)} releases')
            package_data = pool.map(self._load_release_from_cache, final_releases)

        for release, release_data, last_date_created in package_data:
            self._init_release(release, release_data, last_date_created)

        self._order_packages()

    def _load_release_from_cache(self, release: str)  -> dict:
        data = {}

        try:
            with open(os.path.join(os.path.expanduser(PKG_CACHE_DIR), release.replace('/', '_') + '-pkg-cache.json')) as f:
                data = json.load(f)
        except FileNotFoundError as ex:
            print(ex)
            return (release, None, None)

        release_data = {}
        latest_date_created = None
        release_obj = Release(release)
        for src_pkg_name, src_pkg_versions in data.items():
            if src_pkg_name == 'latest_date_created':
                latest_date_created = datetime.datetime.fromtimestamp(src_pkg_versions)
                continue
            source_package = UbuntuSourcePackage(src_pkg_name, {})

            release_data[src_pkg_name] = source_package
            for src_pkg_version, src_pkg_version_data in src_pkg_versions.items():
                src_pkg_version_obj = UbuntuVersion(src_pkg_version)
                source_package.add_source_version(src_pkg_version_obj, release_obj,
                                                  src_pkg_version_data['component'], 
                                                  src_pkg_version_data['pocket'])

                for binary_name, binary_data in src_pkg_version_data['binaries'].items():
                    source_package.add_binary(src_pkg_version_obj, UbuntuBinaryPackage(binary_name, 
                                                                  UbuntuVersion(binary_data['version']), 
                                                                  binary_data['arch'], 
                                                                  source_package,
                                                                  binary_data['component']))

        return (release_obj, release_data, latest_date_created)
    
    def _init_release(self, release: Release, release_data: dict, latest_date_created: str) -> None:
        if not release_data: return
        for package_name in release_data:
            if package_name in self.packages:
                self.packages[package_name].expand_versions(release_data[package_name])
            else:
                self.packages[package_name] = release_data[package_name]
        
        self.latest_date_created[release] = latest_date_created
        self.loaded_releases.add(release)

    def get_package(self, pkg_name: str) -> UbuntuSourcePackage:
        return super().get_package(pkg_name)

    def load_release(self, release:str) -> None:
        if Release(release) in self.loaded_releases: return
        release_obj, data, date = self._load_release_from_cache(release)
        self._init_release(release_obj, data, date)

    def unload_release(self, release: str) -> None:
        release = Release(release)
        if release not in self.loaded_releases: return
        self.loaded_releases.remove(release)

        for package_name, package in self.packages.items():
            original_source_versions = package.source_versions.copy()
            for version in original_source_versions:
                ver_rel = package.get_version_release(version)
                if ver_rel == release: package.remove_version(version)

class UCTCVEStorage(CVEStorage):
    """
    Storage class for handling UCT CVE packages.
    """
    cves: dict[str: UbuntuCVE]
    package_storage: UCTPackageStorage

    # TODO: add a changed cache so we can cache CVEs and only update when something got loaded

    def load(self, cves_filter: list = []) -> None:
        final_cves = []
        cves_ids = self.get_uct_cve_ids()
        for cve_id in cves_ids:
            if cves_filter and cve_id not in cves_filter: continue
            final_cves.append(cve_id)

        with Pool(processes=os.cpu_count()) as pool:
            print(f'Loading {len(final_cves)} CVEs')
            cves = pool.map(self._uct_cve_loader, final_cves)

        for cve, cve_pkg_data in cves:
            if not cve: continue
            self._init_cve(cve, cve_pkg_data)

        self._order_cves()

    def _uct_cve_loader(self, cve_id: str) -> UbuntuCVE:
        """Internal function to load CVE from UCT"""
        data = {}
        for directory in cve_lib.cve_dirs:
            try:
                data = cve_lib.load_cve(os.path.join(UCT, directory, cve_id))
            except:
                continue
        
        if not data:
            raise FileNotFoundError(f'Couldn\'t find CVE {cve_id}')

        cvss = []
        for cvss_entry in data['CVSS']:
            if not cvss_entry: continue

            cvss.append(CVSS(
                cvss_entry['source'],
                float(cvss_entry['baseScore']),
                cvss_entry['vector']
            ))

        try:
            cve = UbuntuCVE(data['Candidate'], data['Description'].strip().replace('\n', ' '), data['PublicDate'], cvss, 
                            data['Assigned-to'], data['Notes'], data['References'].strip().split('\n'), data['Priority'][0], data['Priority'][1])
        except Exception as ex:
            print(ex)
            return (None, None)
        
        return (cve, data['pkgs'])

    def get_uct_cve_ids(self) -> list:
        """Return all CVE IDs identified from UCT"""

        cve_ids = []
        for dir in cve_lib.cve_dirs:
            for (_, _, filenames) in os.walk(dir):
                for filename in filenames:
                    if not re.search(CVE.ID_REGEX, filename): continue
                    cve_ids.append(filename)
                break
        
        return cve_ids

    def load_cve(self, cve_id: str) -> None:
        """Load a CVE into the storage"""
        cve, cve_data = self._uct_cve_loader(cve_id)
        self._init_cve(cve, cve_data)

    def get_all_cves(self) -> list[UbuntuCVE]:
        """Get all CVEs from the storage"""
        cves = []
        for cve_id in self.cves:
            cves.append(self.get_cve(cve_id))
        return cves

    def get_all_rel_cves(self, release: Release) -> list[UbuntuCVE]:
        """Get all CVEs from the storage affecting a release"""
        cves = []
        for cve_id in self.cves:
            cve = self.get_cve(cve_id)
            if cve.is_rel_present(release):
                cves.append()
        return cves

    def populate_cve_entries(self, cve_id: str) -> None:
        cve, cve_pkg_data = self.cves[cve_id]
        cve.pkg_entries = list()
        for package_name, package_entries in cve_pkg_data.items():
            package = self.package_storage.get_package(package_name)
            if not package: continue
            for release, status in package_entries.items():
                release = Release(release)
                if not package.release_exists(release, include_parents=True): continue
                cve.add_cve_entry(UbuntuCVEPkgEntry(package, cve, status[0], status[1], release))

    def get_cve(self, cve_id: str, with_pkg_links: bool = True) -> UbuntuCVE:
        """
        Get a CVE from the storage.
        The package links will be computed when the
        CVE is requested, extracting them from the internal
        UCTPackageStorage.

        If with_pkg_links is disabled, links won't be computed
        """
        if cve_id not in self.cves: return None

        cve, _ = self.cves[cve_id]
        cve.pkg_entries = list()
        if not with_pkg_links: return cve
        self.populate_cve_entries(cve_id)

        return cve

class USNStorage(SNStorage):
    sns: dict[str: tuple[USN, list, dict]]
    package_storage: UCTPackageStorage
    cve_storage: UCTCVEStorage

    def load(self) -> None:
        usns_data = self._get_usn_database_data()
        print(f'Loading {len(usns_data)} USNs')
        for usn_id, usn_data in usns_data.items():
            _, _, cves, lp_bugs, pkgs = self.process_usn_data((usn_id, usn_data))
            self.add_usn(usn_id, usn_data, cves, lp_bugs, pkgs)

        self._order_sns()

    def _get_usn_database_data(self) -> dict:
        data = {}
        with open(os.path.expanduser(USN_DATABASE), 'r') as f:
            data.update(json.load(f))
        return data

    def process_usn_data(self, usn_raw: dict) -> tuple[set, set, dict]:
        pkgs = {}
        lp_bugs = set()
        cves = set()
        usn_id = usn_raw[0]
        usn_data = usn_raw[1]
        # Package - fixed version loading
        for rel, info in usn_data['releases'].items():
            # Get package
            for pkg, pkg_info in info['sources'].items():
                pkgs.setdefault(pkg, [])
                pkgs[pkg].append((pkg_info['version'], rel))

        # CVE loading
        for cve_text in usn_data['cves']:
            if 'launchpad.net' in cve_text:
                lp_bugs.add(cve_text)
                continue
            elif re.search(r'CVE-\d{4}-\d{4,7}', cve_text):
                cves.add(cve_text)

        return usn_id, usn_data, cves, lp_bugs, pkgs 
        
    def add_usn(self, usn_id: str, usn_data: dict, cves: set, lp_bugs: set, pkgs: dict) -> None:
        self.sns[usn_id] = (USN(usn_id, usn_data, set(), dict(), lp_bugs), cves, pkgs)

    def get_usns_by_cve(self, cve_id: str) -> list[USN]:
        target_usns = []
        for usn_id, usn_data in self.sns.items():
            if cve_id in usn_data[1]:
                target_usns.append(self.get_usn(usn_id))
        
        return target_usns

    def get_usn(self, usn_id: str) -> USN:
        if usn_id not in self.sns: return None
        usn, cves, pkgs = self.sns[usn_id]
        cve_mapping = set()
        pkg_mapping = dict()

        for cve_id in cves:
            cve = self.cve_storage.get_cve(cve_id)
            if not cve: continue
            cve_mapping.add(cve)
        
        for pkg_name in pkgs:
            pkg = self.package_storage.get_package(pkg_name)
            if not pkg: continue
            for version, release in pkgs[pkg_name]:
                release = Release(release)
                if not pkg.release_exists(release, include_parents=True): continue
                pkg_mapping.setdefault(pkg, [])
                version = UbuntuVersion(version)
                if version.is_esm():
                    for pkg_version in pkg.source_versions:
                        if pkg.get_version_release(pkg_version) == release:
                            release = release.get_esm_release(pkg.get_version_component(pkg_version))
                            break

                pkg_mapping[pkg].append((version, release))

        usn.cves = cve_mapping
        usn.package_fixed_versions = pkg_mapping
        
        return usn


