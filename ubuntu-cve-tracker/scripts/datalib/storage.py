#!/usr/bin/python3
# -*- coding: utf-8 -*-
# Module containing classes that represent CVE and Package data
#
# Author: David Fernandez Gonzalez <david.fernandezgonzalez@canonical.com>
# Copyright (C) 2024 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 2 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.
#
from .models import CVE, SN, SourcePackage

class DirtyCache:
    """
    Cache class for handling modifications
    This class is meant to use with the storage classes.
    The purpose is to know when we need to relink objects
    due to a change in any of the other related storages.

    last_updated is a counter with the last time the cache was changed.
    other_last_updated is a list of counters with the last time
      the other caches were changed.
    """
    dirty_cache: dict[str: bool]
    last_updated: int
    others_last_updated: list[int]

    def __init__(self) -> None:
        self.dirty_cache = {}
        self.others_last_updated = []
        self.last_updated = 0

    def is_dirty(self, id: str, others_last_updated: list[int]) -> bool:
        """
        Check if the select object by id in the cache needs reloading.
        If no self.others_last_updated, that means is dirty because it's first time.
        If any of the other indexes is different, there was a change so everything is dirty.
        """
        if not self.others_last_updated:
            self.mark_dirty()
        else:
            for index in range(len(others_last_updated)):
                if self.others_last_updated[index] < others_last_updated[index]:
                    self.mark_dirty()
                    break
        self.others_last_updated = others_last_updated
        return self.dirty_cache[id]

    def add(self, id: str) -> None:
        self.dirty_cache[id] = True

    def make_clean(self, id: str) -> None:
        self.dirty_cache[id] = False

    def mark_dirty(self) -> None:
        for item in self.dirty_cache:
            self.dirty_cache[item] = True

    def increment_last_updated(self) -> None:
        self.last_updated += 1

class PackageStorage:
    """
    Storage class for handling packages.
    """
    packages: dict[str: SourcePackage]
    dirty_cache: DirtyCache

    def __init__(self) -> None:
        self.dirty_cache = DirtyCache()
        self.packages = {}

    def _order_packages(self) -> None:
        self.packages = dict(sorted(self.packages.items()))

    def get_package(self, pkg_name: str) -> SourcePackage:
        if pkg_name not in self.packages: return None
        return self.packages[pkg_name]

class CVEStorage:
    """
    Storage class for handling CVE packages.
    """
    cves: dict[str: CVE]
    package_storage: PackageStorage
    dirty_cache: DirtyCache

    # TODO: add a changed cache so we can cache CVEs and only update when something got loaded

    def __init__(self) -> None:
        self.cves = {}
        self.dirty_cache = DirtyCache()

    def link_pkg_storage(self, package_storage: PackageStorage) -> None:
        self.package_storage = package_storage

    def _order_cves(self) -> None:
        self.cves = dict(sorted(self.cves.items(),
                                key=lambda value: int(value[0].split('-')[1]) * 10 ** 8 + int(value[0].split('-')[2])))

    def _init_cve(self, cve: CVE, pkg_data: dict) -> None:
        """Internal function to add CVE object to the class storage"""
        self.cves[cve.id] = (cve, pkg_data)
        self.dirty_cache.add(cve.id)

    def load_cve(self, cve_id: str) -> None:
        """Load a CVE into the storage"""
        raise NotImplementedError

    def get_cve(self, cve_id: str) -> CVE:
        """
        Get a CVE from the storage.
        The package links will be computed when the
        CVE is requested, extracting them from the internal
        PackageStorage.
        """
        raise NotImplementedError

class SNStorage:
    sns: dict[str: SN]
    package_storage: PackageStorage
    cve_storage: CVEStorage
    dirty_cache: DirtyCache

    def __init__(self) -> None:
        self.sns = {}
        self.dirty_cache = DirtyCache()

    def _init_sn(self, sn_object: SN, cves: set, pkgs: dict):
        self.sns[sn_object.id] = (sn_object, cves, pkgs)
        self.dirty_cache.add(sn_object.id)

    def _order_sns(self) -> None:
        self.sns = dict(sorted(self.sns.items(),
                               key=lambda value: int(value[0].split('-')[0]) * 10 ** 8 + int(value[0].split('-')[1])))

    def link_pkg_storage(self, package_storage: PackageStorage) -> None:
        self.package_storage = package_storage

    def link_cve_storage(self, cve_storage: CVEStorage) -> None:
        self.cve_storage = cve_storage

    def load_sn(self, object: SN) -> None:
        return NotImplementedError
